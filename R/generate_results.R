#' @title A function that takes a list of raw simulation results
#' and processes them
#'
#' @description This function processes simulation results generated by
#' calling one or multiple simulation functions.
#'
#' @param simlist a nested list of results from call(s) to the simulation functions
#' @param modelsettings a list with model settings information, usually from generate_modelsettings()
#' @return A vectored list named "result" with each main list element containing the simulation results in a dataframe called dat and associated metadata required for generate_plot and generate_text functions. Most often there is only one main list entry (result[[1]]) for a single plot/text.
#' @details This function processes and aggregates simulation results generated from a single set of modelsettings.
#' @importFrom utils head tail
#' @importFrom stats reshape
#' @export

generate_output <- function(simlist,modelsettings) {

  # will hold information to be returned
  result <- vector(list(),length(simlist))

  ##################################
  #default for text display, used by most basic simulation models
  #can/will be potentially overwritten below for specific types of models
  ##################################

  result[[1]]$maketext = TRUE #indicate if we want the generate_text function to process data and generate text
  result[[1]]$showtext = NULL #text can be added here which will be passed through to generate_text and displayed for EACH plot
  result[[1]]$finaltext = 'Numbers are rounded to 2 significant digits.' #text can be added to this, which will be passed through to generate_text and displayed once

  ##################################
  #default for plot display, used by most basic simulation models
  #can/will be potentially overwritten below for specific types of models
  ##################################
  result[[1]]$plottype = "Lineplot"
  result[[1]]$xlab = "Time"
  result[[1]]$ylab = "Numbers"
  result[[1]]$legend = "Compartments"

  #if plotscale is not provided, assume no log scales for x and y, i.e. set to ''
  plotscale = ifelse(is.null(modelsettings$plotscale),'',modelsettings$plotscale)
  result[[1]]$xscale = 'identity'
  result[[1]]$yscale = 'identity'
  if (plotscale == 'x' | plotscale == 'both') { result[[1]]$xscale = 'log10'}
  if (plotscale == 'y' | plotscale == 'both') { result[[1]]$yscale = 'log10'}



  noutbreaks = 0 #tracking fraction of outbreaks for stochastic models

  # loop over each simulation call, process as needed
  # each type of underlying simulator needs different processing
  for (n in 1:length(simlist))
  {
    sim <- simlist[[n]]

    ##################################
    #ode model
    ##################################
    if (grepl('_ode',modelsettings[[n]]))
    {
      simresult <- sim$ts
      if (length(simlist)>1) #this means another model was also run, relabel variables to indicate ODE
      {
        colnames(simresult) = paste0(colnames(simresult),'_ode')
      }
      colnames(simresult)[1] = 'xvals' #rename time to xvals for consistent plotting
      #reformat data to be in the right format for plotting
      rawdat = as.data.frame(simresult)
      #using basic reshape function to reformat data
      dat = stats::reshape(rawdat, varying = colnames(rawdat)[-1], v.names = 'yvals', timevar = "varnames", times = colnames(rawdat)[-1], direction = 'long', new.row.names = NULL);
      dat$id <- NULL
      #dat$IDvar = dat$varnames #make variables in case data is combined with stochastic runs. not used for ode.
      dat$nreps = 1
      datall[[n]] = dat
    }

    ##################################
    #discrete model
    ##################################
    if (grepl('_discrete',fctcalls[[n]]))
    {
      simresult <- sim$ts
      if (length(simlist)>1) #this means another model was also run, relabel variables to indicate ODE
      {
        colnames(simresult) = paste0(colnames(simresult),'_dis')
      }
      colnames(simresult)[1] = 'xvals' #rename time to xvals for consistent plotting
      #reformat data to be in the right format for plotting
      rawdat = as.data.frame(simresult)
      #using basic reshape function to reformat data
      dat = stats::reshape(rawdat, varying = colnames(rawdat)[-1], v.names = 'yvals', timevar = "varnames", times = colnames(rawdat)[-1], direction = 'long', new.row.names = NULL);
      dat$id <- NULL
      #dat$IDvar = dat$varnames #make variables in case data is combined with stochastic runs. not used for discrete.
      dat$nreps = 1
      datall[[n]] = dat
    }


    ##################################
    #stochastic model
    ##################################
    if (grepl('_stochastic',fctcalls[[n]]))
    {
        simresult <- sim$ts
        colnames(simresult)[1] = 'xvals' #rename time to xvals for consistent plotting
        #reformat data to be in the right format for plotting
        rawdat = as.data.frame(simresult)
        #using basic reshape function to reformat data
        dat = stats::reshape(rawdat, varying = colnames(rawdat)[-1], v.names = 'yvals', timevar = "varnames", times = colnames(rawdat)[-1], direction = 'long', new.row.names = NULL);
        dat$id <- NULL
        #dat$IDvar = dat$varnames #make a variable for plotting same color lines for each run in ggplot2
        dat$nreps = n
        datall[[n]] = dat

        #keep track of outbreaks occurrence among stochastic simulations
        S0=head(simresult[,2],1)
        Sfinal=tail(simresult[,2],1)
        if ( (S0-Sfinal)/S0>0.2 ) {noutbreaks = noutbreaks + 1}
        #text is updated each time for multiple stochastic simulations
        finaltext = paste('For stochastic simulation scenarios, values shown are the mean over all simulations.', noutbreaks,' simulations produced an outbreak (susceptible/uninfected dropped by at least 20%)')
    }

    ##################################
    #model exploration
    ##################################
    if (grepl('_modelexploration',fctcalls[[n]]))
    {

      simresult <- sim
      steady = simresult$dat$steady

      #these 3 settings are only needed for the shiny UI presentation
      result[[n]]$maketext = FALSE
      result[[n]]$showtext = NULL #text for each plot can be added here which will be passed through to generate_text and displayed for each plot
      result[[n]]$finaltext = paste("System might not have reached steady state", length(steady) - sum(steady), "times")

      #Meta-information for each plot
      result[[n]]$plottype = "Scatterplot"
      result[[n]]$xlab = modelsettings$samplepar
      result[[n]]$ylab = "Outcomes"
      result[[n]]$legend = "Outcomes"
      result[[n]]$linesize = 3

      simresult$dat$steady <- NULL #remove before return so it won't be plotted
      result[[n]]$dat = simresult$dat
    }

    ##################################
    #Code block for US analysis
    ##################################
    if (grepl('_usanalysis',fctcalls[[n]]))
    {
      simresult <- sim
      #pull the indicator for non-steady state out of the dataframe, process separately
      steady = simresult$dat$steady
      simresult$dat$steady <- NULL
      simdat = simresult$dat

      #number of columns - each outcome gets a column
      result[[n]]$ncols = modelsettings$nplots

      #loop over each outer list element corresponding to a plot and fill it with another list
      #of meta-data and data needed to create each plot
      #each parameter-output pair is its own plot, therefore its own list entry
      ct=1; #some counter
      for (nn in 1:modelsettings$nplots) #for specified parameter, loop over outcomes
      {
        #data frame for each plot
        xvals = simdat[,modelsettings$samplepar] #get parameter under consideration
        xvalname = modelsettings$samplepar
        yvals = simdat[,nn] #first 3 elements are outcomes
        yvalname = colnames(simdat)[nn]
        dat = data.frame(xvals = xvals, yvals = yvals, varnames = yvalname)
        result[[ct]]$dat = dat

        #meta-data for each plot
        result[[ct]]$plottype = modelsettings$plottype
        result[[ct]]$xlab = xvalname
        result[[ct]]$ylab = yvalname
        result[[ct]]$makelegend = FALSE #no legend for these plots

        #if plotscale is not provided, assume no log scales for x and y, i.e. set to ''
        plotscale = ifelse(is.null(modelsettings$plotscale),'',modelsettings$plotscale)

        result[[ct]]$xscale = 'identity'
        result[[ct]]$yscale = 'identity'
        if (plotscale == 'x' | plotscale == 'both') { result[[ct]]$xscale = 'log10'}
        if (plotscale == 'y' | plotscale == 'both') { result[[ct]]$yscale = 'log10'}

        #the following are for text display for each plot
        result[[ct]]$maketext = TRUE #if true we want the generate_text function to process data and generate text, if 0 no result processing will occur inside generate_text
        result[[ct]]$finaltext = paste("System might not have reached steady state", length(steady) - sum(steady), "times")

        #set y-axis limits based on variable
        result[[ct]]$ymin = min(result[[ct]]$dat$yvals, na.rm=TRUE)
        result[[ct]]$ymax = max(result[[ct]]$dat$yvals, na.rm=TRUE)

        ct = ct + 1
      } #loop over plots
    }
    ##################################
    #end US analysis model code block
    ##################################



  } #end loop over all simulations in simlist

  #return result structure to calling function
  #results need to be in a form that they
  #can be sent to the plot and text functions to generate results
  return(result)

}




  ##################################
  #model fitting code block
  ##################################
  if (grepl('_fit_',modelsettings$modeltype))
  {
    #send result from simulator to a check function. If that function does not return null, exit run_model with error message
    simresult = resultslist[[which(grepl("_fit_", expected_sim_results))]]

    checkres <- check_results(simresult)
    if (!is.null(checkres)) {return(checkres)}


    colnames(simresult$ts)[1] = 'xvals' #rename time to xvals for consistent plotting
    #reformat data to be in the right format for plotting
    #each plot/text output is a list entry with a data frame in form xvals, yvals, extra variables for stratification for each plot
    rawdat = as.data.frame(simresult$ts)
    #using basic reshape function to reformat data
    dat = stats::reshape(rawdat, varying = colnames(rawdat)[-1], v.names = 'yvals', timevar = "varnames", times = colnames(rawdat)[-1], direction = 'long', new.row.names = NULL); dat$id <- NULL

    dat$style = 'line'

    #next, add data that's being fit to data frame
    fitdata  = simresult$data
    fitdata$style = 'point'
    datall = rbind(dat,fitdata)

    #code variable names as factor and level them so they show up right in plot
    mylevels = unique(datall$varnames)
    datall$varnames = factor(datall$varnames, levels = mylevels)

    #data for plots and text
    #each variable listed in the varnames column will be plotted on the y-axis, with its values in yvals
    #each variable listed in varnames will also be processed to produce text
    result[[1]]$dat = datall


    #Meta-information for each plot
    result[[1]]$plottype = "Mixedplot"
    result[[1]]$xlab = "Time"
    result[[1]]$ylab = "Numbers"
    result[[1]]$legend = "Compartments"

    result[[1]]$maketext = FALSE
    result[[1]]$showtext = NULL

    ####################################################
    #different choices for text display for different fit models
    #both DSAIDE and DSAIRM models
    if (grepl('flu_fit',simfunction) || grepl('basicvirus_fit',simfunction))
    {
      txt1 <- paste('Best fit values for parameters',paste(names(simresult$bestpars), collapse = '/'), ' are ', paste(format(simresult$bestpars,  digits =2, nsmall = 2), collapse = '/' ))
      txt2 <- paste('Final SSR is ', format(simresult$SSR, digits =2, nsmall = 2))
      result[[1]]$finaltext = paste(txt1,txt2, sep = "<br/>")
    }
    if (grepl('confint_fit',simfunction))
    {
      txt1 <- paste('Best fit values for parameters', paste(names(simresult$bestpars), collapse = '/'), ' are ', paste(format(simresult$bestpars,  digits =2, nsmall = 2), collapse = '/' ))
      txt2 <- paste('Lower and upper bounds for parameter', paste(names(simresult$bestpars[1]), collapse = '/'), ' are ', paste(format(simresult$confint[1:2],  digits =2, nsmall = 2), collapse = '/' ))
      txt3 <- paste('Lower and upper bounds for parameter', paste(names(simresult$bestpars[2]), collapse = '/'), ' are ', paste(format(simresult$confint[3:4],  digits =2, nsmall = 2), collapse = '/' ))
      txt4 <- paste('SSR is ', format(simresult$SSR, digits =2, nsmall = 2))
      result[[1]]$finaltext = paste(txt1,txt2,txt3,txt4, sep = "<br/>")
    }
    if (grepl('noro_fit',simfunction) || grepl('fludrug_fit',simfunction) || grepl('modelcomparison_fit',simfunction) || grepl('bacteria_fit',simfunction))
    {
      txt1 <- paste('Best fit values for model', modelsettings$fitmodel, 'parameters',paste(names(simresult$bestpars), collapse = '/'), ' are ', paste(format(simresult$bestpars,  digits =2, nsmall = 2), collapse = '/' ))
      txt2 <- paste('SSR and AICc are ',format(simresult$SSR, digits =2, nsmall = 2),' and ',format(simresult$AICc, digits =2, nsmall = 2))
      result[[1]]$finaltext = paste(txt1,txt2, sep = "<br/>")
    }

  }
  ##################################
  #end model fitting code block
  ##################################




